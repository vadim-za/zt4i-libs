# Intrusive lists quick howto

This document gives a quick howto-style introduction into intrusive list support by the CC library.

[Double-linked lists](#double-linked-lists)
- [Declaration](#double-linked-list-declaration)
- [Construction/destruction](#double-linked-list-constructiondestruction)
- [Insertion/removal](#double-linked-list-node-insertionremoval)
- [Inspection](#double-linked-list-inspection)

[Single-linked lists](#single-linked-lists)

## Double-linked lists

### Double-linked list declaration

Define list and node types:
```
const MyNode = struct {
    field1: Type1,
    field2: Type2,

    // Usually you need only one hook. Define multiple hooks if
    // you plan to use the node in multiple lists simultaneously.
    hook: MyList.Hook = .{},
};

const MyList = zt4i.cc.List(MyNode, .{
    .implementation = .{ .double_linked = .null_terminated },
    .hook_field = "hook",
    .ownership_tracking = .{
        .owned_items = .container_ptr,
        .free_items = .on,
    },
});
```

### Double-linked list construction/destruction

N.B. The following examples demonstrate constructing a list as a local variable (to be temporarily used inside a function). More typically, a list would be a field of a larger struct.
```
    // This pattern is applicable to the majority of
    // the CC containers
    var list: MyList = .{};
    defer list.deinit();
```
The above construction pattern works for the absolute majority of cases. However if you want to be able to switch between different CC implementations of double-linked lists, consider using the following pattern, which is compatible to all of them:
```
    // This pattern is applicable to all CC containers
    var list: MyList = undefined;
    list.init();
    defer list.deinit();
```
Generally speaking, you must empty the list prior to `list.deinit()` (there are some exceptions to that rule, explained in the detailed part of the documentation).
If you don't want to remove the nodes one by one, you can empty the entire list by calling `list.removeAll()`:
```
    var list: MyList = .{};
    defer {
        // N.B. removeAll() doesn't destroy the nodes!
        list.removeAll();
        list.deinit();
    }
```
`list.removeAll()` doesn't destroy the nodes, it only removes them from the list. If you also need to destroy them, you could do something like
```
    var list: MyList = .{};
    defer {
        // Alternatively could use list.popFirst()
        while(list.popLast()) |node|
            alloc.destroy(node);
        list.deinit();
    }
```

### Double-linked list node insertion/removal

N.B. For the sake of simplicity of demonstration in the following examples we dynamically create and destroy the nodes one-by-one. In intrusive scenarios it is however more likely that the nodes are preallocated in some way. In theory, they can even be created as local variables on the stack, provided their lifetimes do not exceed their insertion durations.
```
    const node = try alloc.create(Node);
    // At the very least, the hook field must be initialized
    // to .{} prior to inserting the node into the list. In
    // the Node declaration example above we already have
    // specified .{}' as the hook's default value, so we don't
    // have to explicitly initialize the hook here.
    node.* = .{ .field1 = value1, .field2 = value2 };
    list.insertFirst(node);
    ..........
    list.remove(node);
    alloc.destroy(node);
```
The following insertion methods are available for double-linked lists:
```
    // node1...node4 are of the *Node type
    list.insertFirst(node1);
    list.insertLast(node2);
    list.insertBefore(node1, node3);
    list.insertAfter(node2, node4);
```
There is also a more versatile helper `insert()` method, which wraps the primary insertion methods demonstrated above:
```
    // node1...node6 are of the *Node type
    list.insert(.first, node1);
    list.insert(.last, node2);
    list.insert(.before(node1), node3);
    list.insert(.after(node2), node4);
    list.insert(.before(null), node5); // inserts last
    list.insert(.after(null), node6); // inserts first
```
N.B. The `insert()` method relies on compiler optimizations to generate the code which is as efficient as the code that would have been generated by calling the primary insertion methods directly. In highly performance critical code you might want to use the primary methods.

The `removeAll()`, `popFirst()` and `popLast()` methods have been demonstrated earlier.

### Double-linked list inspection

```
    // Forward-iteration of (any) double-linked
    // or (any) single-linked list
    var node = list.first(); // node's type is '?*Node'
    while(node) |n| : (node = list.next(n)) {
        // n's type is '*Node'
        doSomething(n);
    }

    // Backward-iteration of (any) double-linked list
    var node = list.last(); // node's type is '?*Node'
    while(node) |n| : (node = list.prev(n)) {
        // n's type is '*Node'
        doSomething(n);
    }

    // Just checking whether the list contains any nodes
    if(list.hasContents())
        std.debug.print("List is non-empty\n", .{});
```
The `first()`, `last()`, `next()` and `prev()` methods are not restricted to iterating through the whole list, they can be freely used for a generic list inspection.

## Single-linked lists

The basic single-linked list API is a subset of double-linked list API. The notable differences include:
- No access to or manipulation of the last element (unless `.double_ptr` single-linked list implementation is used, in which case limited access/manipulation is available)
- No backward iteration
- No `insertBefore()`
- Instead of `remove()` there is `removeFirst()`.

Declaration example:
```
// MyNode is assumed to be defined in the same way
// as in the double-linked list example earlier.

const MyList = zt4i.cc.List(MyNode, .{
    .implementation = .{ .single_linked = .single_ptr },
    .hook_field = "hook",
    .ownership_tracking = .{
        .owned_items = .container_ptr,
        .free_items = .on,
    },
});
```

